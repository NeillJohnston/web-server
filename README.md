# web-server

The server that runs [my website.](https://neilljohnston.com)

It's a simple HTTP server with some nice features to help put together a small website, such as HTTPS and support for dynamic content based on SQL queries.

## Setup

This server runs on Ubuntu 18.04. Haven't tested any other distros, and I imagine it only works on Linux.

### Dependencies

The server depends on two libraries: SQLite and OpenSSL.

For SQLite, download the "amalgamation" (their words, not mine) from their website, and drop the contents (.c and .h files) into src/sqlite.

For OpenSSL, you need to install `libssl`:

```
sudo apt-get install libssl-dev
```

### Building

Navigate to the root directory (the same directory that this README is in) and:

```
make
```

If `make` runs without error, you're good.
The standalone server executable should be in the /out directory.
The SQLite shell will also be compiled and located in /out.

## Flow of a single request

0. The server is started with a valid config.
1. A browser attempts to connect to [your-domain].
	- If the request is made over HTTP, the redirect server sends a `301 Permanently Moved` with a location redirecting the browser to use HTTPS.
	- If the request is made over HTTPS, the main server picks up the connection and parses the request.
2. A new worker process is spawned to fulfill the request.
3. The request is sent to the router to decide what to do. If the router finds a matching route in the routing table, it forwards the request to the proper sub-router. If no match is found, it forwards the request to the `static` sub-router.
	- The `static` sub-router is given a path and tries to find a matching file. If no file is found, `404 Not Found` is returned. If a file is found, the contents of the file is returned.
	- The `dynamic` sub-router is given a path and tries to find a matching SQL file. If a file is found, the SQL query is executed on the database and the result is returned as a JSON-encoded string.
5. When the worker thread receives the fulfilled response (or a `500 Internal Error` in case of errors), it sends this back to the client.

# Usage

## Running

```
<server executable> <path to config file>
```

The server executable generated by `make` is located at /out/server.

## Config

The only argument required to launch the server is a path to a config file. The config file contains key-value pairs (one line per pair, key/value separated by whitespace).

Several options are required for the full experience:

```
root    (root folder of server files)
db      (path to a SQLite database)
# For certification purposes:
domain	(domain that this server is hosting)
cert    (path to full-chain certification file, .pem)
pkey    (path to SSL private key file, .pem)
```

The optional options are:

```
dev     (whether to run in dev mode or not? default: false)
port    (what port should connections be made on? default: 443)
back    (how large of a queue should the server hold for incoming connections? default: 128)
```

The "required" certification options can be ommitted if `dev` is `true`.

### Dev mode

To test a website, it makes sense to just run it on some port over localhost. To do this, specify a port and set `dev` to `true` in your config.

The main difference is that the dev server will run over HTTP, not HTTPS. You can use this to test without needing to actually host a website.

## Routing

Routing paths are specified by the DB. The server expects a table named `routes` to exist, with columns `method(VARCHAR)`, `route(VARCHAR)`, `path(VARCHAR)`, and `type(INT)`.

Each row represents a route. `method` is the request method the user sent and `route` is the request URI that a user tries to access. `path` is the file that the route maps to and `type` is a magic number that specifies how the `path` should be interpreted:

-	`0`: Static file, return this in its entirety as the content of the HTTP response.
-	`1`: Database query, execute the file located at `PATH` as a SQL query to the database and return the result (if any) as a JSON string. If the query requires parameters, they should be specified in the body of the HTTP request. The object that gets parsed will be an array, where each element is a row of the returned query. An empty array will be returned in case of errors.
-	Any other values for `type` will trigger a 500.

Example `routes` table:

```
method  route           path            type
------- --------------- --------------- -------
GET     /               /index.html     0
GET     /foo            /foo/index.html 0
GET     /api/bar        /query/bar.sql  1
POST    /api/baz        /query/baz.sql  1
ERROR   404             /404/index.html 0
```

If no row is found for the specified route and method, the server's response depends on the method:

-	For `GET` requests, attempt to reroute to the file specified by the request URI relative to the server root (i.e., treat the request as an attempt to get a file as normal).
-	For all other requests, trigger a 404.

### Errors

You can also use an HTTP error code as the value for `route`. If the server encounters any error, it will look for a row in `routes` with `(method='ERROR', route=<error code>)`. If a row is found, the server will attempt to reroute and use that as the response body, keeping the original reponse code. If that reroute fails, a 500 is triggered that will return the default response body. Otherwise, if no row is found, a default response is provided. Note the method name is "ERROR". This is chosen to avoid potential conflicts with real HTTP requests, and make it impossible to directly request for errors.